import { doc, addDoc, collection, deleteDoc, onSnapshot, Firestore } from '@firebase/firestore';
import { onAuthStateChanged } from '@firebase/auth';

import { RequestConnector } from '@osnova/events';
import { RequestEvent } from '@osnova/events/EventRequest';
import { AnyResponseEventMap } from '@osnova/events/EventResponse';
import { Unsubscribe } from '@osnova/events/lib/Unsubscribe';
import { FirebaseModule, onCollection } from '@osnova/firebase-client';

import { FirestoreEventTransferer } from './FirestoreEventTransferer';

export class FirestoreConnector<ReqEvent extends RequestEvent> {
  private userId: string | null = null;
  private answersListListener: Unsubscribe | null = null;
  private connector: RequestConnector<any, any>;

  constructor(protected firebase: FirebaseModule) {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    this.connector = new RequestConnector(
      new FirestoreEventTransferer(firebase.firestore, () => {
        return `services/EventLog/userEvents/${self.userId}/fromUser`;
      }),
      {
        generateId: false,
      }
    );

    this.initializeListeners();
  }

  getConnector() {
    return this.connector;
  }

  protected releaseAnswersListListener() {
    if (this.answersListListener) {
      this.answersListListener();
      this.answersListListener = null;
    }
  }

  protected listenAnswersList() {
    this.releaseAnswersListListener();

    this.answersListListener = onSnapshot(
      collection(this.firebase.firestore, `services/EventLog/userEvents/${this.userId}/toUser`),
      (snap) => {
        snap.docChanges().forEach((change) => {
          const newAnswer = change.type === 'added';
          const data = change.doc.data();
          const requestId = change.doc.id;
          if (newAnswer && data.done) {
            this.connector.accept({
              type: 'command::response',
              requestId,
              payload: {
                result: data.result,
              },
            });
          }

          if (change.type !== 'removed') {
            deleteDoc(doc(this.firebase.firestore, `services/EventLog/userEvents/${this.userId}/toUser/${requestId}`));
          }
        });
      }
    );
  }

  protected initializeListeners() {
    onAuthStateChanged(this.firebase.auth, (user) => {
      if (user) {
        this.userId = user.uid;
        this.listenAnswersList();
      } else {
        this.releaseAnswersListListener();
      }
    });
  }

  public async command<Cmd extends ReqEvent>(cmd: Cmd) {
    if (!this.userId) {
      throw new Error(`Unable to execute command: not logged in`);
    }

    const commandResult = await this.connector.request(cmd);

    return commandResult;
  }
}

export type FirestoreConnectorOptions = {
  requestsCollection: string;
  responsesCollection: string;
  deleteResponse: boolean;
};

// export class FirestoreConnector<
//   OutEvent extends RequestEvent,
//   Responses extends AnyResponseEventMap
// > extends RequestConnector<OutEvent, Responses> {
//   private options: FirestoreConnectorOptions;

//   private responseListener: Unsubscribe | null = null;

//   constructor(private firestore: Firestore, options: FirestoreConnectorOptions) {
//     super(
//       new PostMessageTransferer({
//         async postMessage(event) {
//           const db = firestore;
//           const docRef = await addDoc(collection(db, )) (options.requestsCollection).doc();

//           docRef.set(event);

//           // Set Id of an event with one generated by Firebase
//           event['id'] = docRef.id;
//         },
//       }),
//       {
//         generateId: false,
//       }
//     );

//     this.options = options;

//     this.listenResponses();
//   }

//   public listenResponses() {
//     const root = this.options.responsesCollection;

//     // Release previously registered listener if any
//     this.releaseResponseListener();

//     this.responseListener = onCollection<Responses[keyof Responses]>(this.firebase, root, {
//       onNewDoc: (data) => {
//         this.accept(data);
//       },
//       removeAfterProcessed: this.options.deleteResponse,
//     });

//     return this.responseListener;
//   }

//   public releaseResponseListener() {
//     if (this.responseListener) {
//       this.responseListener();
//       this.responseListener = null;
//     }
//   }
// }
